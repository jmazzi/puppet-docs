Language Tutorial
=================

The purpose of Puppet's language is to make it easy to specify the
resources you need to manage on the machines you're managing. 

This guide will show you how the language works, going through
some basic concepts.  Understanding
the Puppet language is key, as it's the main driver of how
you tell your Puppet managed machines what to do.

Afterwards, you may wish to look at the [Extended Language Tutorial](./more_language.html) for further information.

* * *

Ready To Dive In?
-----------------

Puppet language is really relatively simple compared to many
programming languages.  As you are reading over this guide,
it may also be helpful to look over various Puppet modules
people have already written.   Complete real world examples
can serve as a great introduction to Puppet.  See the [Modules]
(/github/modules.html) page for more information and some
links to list of community developed Puppet content.

Resources
---------

The fundamental unit of modelling in Puppet is a resource.  Resources
describe some aspect of a system; it might be a file, a service, a 
package, or perhaps even a custom resource that you have developed.
We'll show later how resources can be aggregrated together with 
"defines" and "classes", and even show how to organize things
with "modules", but resources are what we should start with first.

Each resource has a type, a title, and a list
of attributes -- each resource in Puppet can support various attributes,
though many of them will have reasonable defaults and you won't have
to specify all of them.

You can find all of the supported resource
types, their valid attributes, and documentation for all of it in
the [Type Guides](./types/) and [References](/references/).
The guides section will provide in depth examples and commentary, where
as the references version is autogenerated (and also available for past
versions of Puppet).  We would recommend starting with the 'guides'.

Let's get started.   Here's a simple example of a resource in Puppet,
where we are describing the permissions and ownership of a file:

    file { '/etc/passwd':
        owner => root,
        group => root,
        mode  => 644,
    }

Any machine on which this snippet is executed will use it to verify
that the passwd file is configured as specified. The field before
the colon is the resource's `title`, which can be used to refer to
the resource in other parts of the Puppet configuration.

For simple resources that don't vary much, a single name is
sufficient.  However, what happens if a filename is different between
operating systems?   For these cases,
Puppet allows you to specify a local name in addition to the
title:

    file { 'sshdconfig':
        name => $operatingsystem ? {
            solaris => '/usr/local/etc/ssh/sshd_config',
            default => '/etc/ssh/sshd_config',
        },
        owner => root,
        group => root,
        mode  => 644,
    }

By using the title, which is always the same, it's easy to refer
to the file resource elsewhere in our configuration without having
to repeat that OS specific logic.

For instance, let's add a service that depends on the file:

    service { 'sshd':
        subscribe => File[sshdconfig],
    }

This will cause the `sshd` service to get restarted when the
`sshdconfig` file changes. You'll notice that when we reference a
resource we capitalise the name of the resource, for example
`File[sshdconfig]`.   When you see an uppercase resource type,
that's always a reference.  A lowercase version is a declaration.
Since resources can only be declared once, repeating the same
declaration twice will cause an error.   This is an important
feature of Puppet that makes sure your configuration is well
modelled.

What happens if our resource depends on multiple resources?
From Puppet version 0.24.6 you can specify multiple relationships
like so:

    service { 'sshd':
        require => File['sshdconfig', 'sshconfig', 'authorized_keys']

It's important to note here that the title alone identifies the resource.
Even if the resource seems to conceptually point to the same entity,
it's the title that matters.  The following is possible in Puppet,
but is to be avoided as it can lead to errors once things get
sent down to the client.

    file { 'sshdconfig':
        name  => '/usr/local/etc/ssh/sshd_config',
        owner => 'root',
    }
    
    file { '/usr/local/etc/ssh/sshd_config':
        owner => 'sshd',
    }

### Metaparameters

In addition to the attributes specific to each Resource Type Puppet also has
global attributes called metaparameters. Metaparameters are
parameters that work with any resource type.

In the examples in the section above we used two metaparameters,
`subscribe` and `require`, both of which build relationships
between resources. You can see the full list of all metaparameters in the
[Metaparameter Reference](/references/stable/metaparameters.html), though
we'll point out additional ones we use as we continue the tutorial.

### Resource Defaults

Sometimes you will need to specify a default parameter value for a set
of resources; Puppet provides a syntax for doing this, using a
capitalized resource specification that has no title.  For instance,
in the example below, we'll set the default path for all execution
of commmands:

    Exec { path => '/usr/bin:/bin:/usr/sbin:/sbin' }
    exec { 'echo this works': }

The first statement in this snippet provides a default value for
`exec` resources; Exec resources require either fully qualified paths or a
path in which to look for the executable. Individual resources can
still override this path when needed, but this saves typing.
This way you can specify a single default path for your entire configuration, and then override that value as necessary.

Defaults work with any resource type in Puppet.

Defaults are not global -- they only affect the current scope and scopes below the current one.  If you want a default setting to affect your entire configuration, your only choice currently is to specify them outside of any class.  We'll mention classes in the next section.

### Resource Collections

Aggregation is a powerful concept in Puppet.  There are two ways to combine multiple resources into one easier to use resource: Classes and definitions. Classes model fundamental aspects of nodes, they say "this node IS a webserver" or "this node is one of these".  In programming terminology classes are
singletons -- they only ever get evaluated once per node.

Definitions, on the other hand, can be reused many times on the same node.  They essentially work as if you created your own Puppet type just by using the language.  They are meant to be evaluated multiple times, with different inputs each time.  This means you can pass variable values into the defines.

Both classes and defines are very useful and you should make use of them when building out your puppet infrastructure.

#### Classes

Classes are introduced with the `class` keyword, and their contents
are wrapped in curly braces.  The following simple example creates a simple class that manages two seperate files:

    class unix {
        file {
            '/etc/passwd': 
                owner => 'root', 
                group => 'root', 
                mode  => 644;
            '/etc/shadow': 
                owner => 'root', 
                group => 'root', 
                mode  => 440;
        }
    }

You'll notice we introduced some shorthand here.   This is the same
as saying:

    class unix {
        file { '/etc/password':
             owner => 'root', 
             group => 'root', 
             mode  => 644;
        }
        file { '/etc/shadow':
             owner => 'root', 
             group => 'root', 
             mode  => 440;
        }
    }

Classes also support a simple form of object inheritance.  For those
not aquainted with programming terms, this means that we can extend
the functionality of the previous class without copy/pasting
the entirity of the code.  Inheritance allows
subclasses to override resource settings defined in parent classes. A
class can only inherit from one other class, not more than one.
In programming terms, this is called 'single inheritance'.

    class freebsd inherits unix {
        File['/etc/passwd'] { group => wheel }
        File['/etc/shadow'] { group => wheel }
    }

If we needed to undo some logic specified in a parent class, we can
use undef like so:

    class freebsd inherits unix {
        File['/etc/passwd'] { group => undef }
    }

In the above example, nodes which include the `unix` class will have the
password file's group set to "wheel", while nodes including
`freebsd` would have the password file group ownership left
unmodified.

In Puppet version 0.24.6 and higher, you can specify multiple overrides like
so:

    class freebsd inherits unix {
        File['/etc/passwd', '/etc/shadow'] { group => wheel }
    }

There are other ways to use inheritance.  In Puppet 0.23.1 and
higher, it's possible to add values to resource parameters using
the '+>' ('plusignment') operator:

    class apache {
        service { 'apache': require => Package['httpd'] }
    }
    
    class apache-ssl inherits apache {
        # host certificate is required for SSL to function
        Service[apache] { require +> File['apache.pem'] }
    }

The above example makes the second class require all the packages in the first,
with the addition of 'apache.pem'.

To append multiple requires, use array brackets and commas:

    class apache {
        service { 'apache': require => Package['httpd'] }
    }
    
    class apache-ssl inherits apache {
        Service[apache] { require +> [ File['apache.pem'], File['/etc/httpd/conf/httpd.conf'] ] }
    }

The above would make the `require` parameter in the `apache-ssl`
class equal to

    [Package['httpd'], File['apache.pem'], File['/etc/httpd/conf/httpd.conf']]

Like resources, you can also create relationships between classes with
'require', like so:

    class apache {
        service { 'apache': require => Class['squid'] }
    }

The above example uses the `require` metaparameter to make the `apache`
class dependent on the `squid` class.

In Puppet version 0.24.6 and higher, you can specify multiple relationships
like so:

    class apache {
        service { 'apache':
                      require => Class['squid', 'xml', 'jakarta']

It's not dangerous to reference a class with a require more than once.
Classes are evaluated using the `include` function (which we will
mention later). If a class has already been evaluated once, then `include` essentially does nothing.

##### Qualification Of Nested Classes

Puppet allows you to nest classes inside one another as a way
of achieving modularity and scoping.  For example:

    class myclass {
    class nested {
        file { '/etc/passwd': 
        owner => 'root', 
        group => 'root', 
        mode  => 644;
        }
    }
    }
    
    class anotherclass {
    include myclass::nested
    }

In this example, the `nested` class inside the outer `myclass` is included as
`myclass::nested` inside of the class named `anotherclass`.  Order is important here.  Class `myclass` must be evaluated before class `anotherclass` for this example to work properly.

#### Definitions

Definitions follow the same basic form as classes, but they are
introduced with the `define` keyword (not `class`) and they support arguments but no inheritance.  As mentioned previously, defines can be reused multiple times on the same system and take parameters.   Suppose we want to create a define that creates source control repositories.  We probably would want to create multiple repositories on the same system, so we would use a define, not a class.  Here's an example:

    define svn_repo($path) {
        exec { "/usr/bin/svnadmin create $path/$title":
            unless => "/bin/test -d $path",
        }
    }
   
    svn_repo { puppet_repo: path => '/var/svn_puppet' }
    svn_repo { other_repo:  path => '/var/svn_other' }

Note how variables can be used within the definitions.  We use dollar sign ($) variables.  Note the use of the variable `$title` above.  This is a bit of technical knowledge, but as of Puppet 0.22.3 and later, definitions can have both a name and a title represented by the `$title` and `$name`
variables respectively. By default, `$title` and `$name` are set to
the same value, but you can set a `title` attribute and pass a
different name as a parameter.  '$title' and '$name' only work in defines,
not in classes or other resources.

Earlier we mentioned that "metaparameters" are attributes that are available on all resource types.  Defined types can also use metaparameters, for instance we can use 'require' inside of a definition.  We can reference the values of those
metaparameters using built-in variables.   Here's an example:

    define svn_repo($path) {
        exec {"create_repo_${name}": 
            command => "/usr/bin/svnadmin create $path/$title",
            unless => "/bin/test -d $path",
        }
        if $require {
            Exec["create_repo_${name}"]{
                require +> $require,
            }
        }
    }
    
    svn_repo { puppet: 
       path => '/var/svn',
       require => Package[subversion],
    }

The above is perhaps not a perfect example, as most likely we'd
know that subversion was always required for svn checkouts.  However
you can see from the above how it's possible to use defined types
with requires and other metaparameters.

#### Classes vs. Definitions

Classes and definitions are created similarly (although classes do
not accept parameters), but they are used very differently.

Definitions are used to define reusable objects which will have
multiple instances on a given host, so they cannot include any
resources that will only have one instance.  For instance, multiple
uses of the same define cannot create the same file.

Classes, on the other hand, are guaranteed to
be singletons -- you can include them as many times as you want and
you'll only ever get one copy of the resources.

Most often, services will be defined in a class, where the
service's package, configuration files, and running service will
all be defined in the class, because there will normally be one
copy of each on a given host.   (This idiom is sometimes
referred to as "service-package-file").

Definitions would be used to manage resources like virtual hosts, of which you can have many, or to encode some simple information in a reusable wrapper to save
typing.

#### Modules

You can (and should!) combine collections of classes, definitions and resources
into modules. Modules are portable collections of configuration,
for example a module might contain all the resources required to
configure Postfix or Apache. You can find out more on the
[Modules Page](./modules.html)

### Nodes

Having knowledge of resources, classes, defines, and modules
gets you to understanding of most of Puppet.   Nodes are a very
simple remaining step, which are how we map the what we define
("this is what a webserver looks like") to what machines are
chosen to fulfill those instructions.

Node definitions look just like classes, including supporting
inheritance, but they are special in that when a node (a managed
computer running puppetd) connects to the Puppet master daemon, its 
name will be looked for in the list of defined nodes.   The information 
found for the node will then be evaluated for that node, and then node will
be sent that configuration.

Node names can be the short host name, or the fully qualified
domain name (FQDN).  Some names, especially fully qualified ones,
need to be quoted, so it is a best practice to quote all of them.
Here's an example:

    node 'www.testing.com' {
       include common 
       include apache, squid
    }

The previous node definition creates a node called
`www.testing.com` and includes the `common`, `apache` and `squid`
classes.  

You can also specify that multiple nodes recieve an indentical
configuration by seperating each with a comma:

    node 'www.testing.com', 'www2.testing.com', 'www3.testing.com' {
       include common 
       include apache, squid
    }

The previous examples creates three identical nodes:
`www.testing.com`, `www2.testing.com`, and `www3.testing.com`.

#### Matching Nodes with Regular Expressions

In Puppet 0.25.0 and later, nodes can also be matched
by regular expressions, which is much more convient than
listing them individually, one-by-one:

    node /^www\d+$/ {
        include common
    }

The above would match any host called `www` and ending with one or more
digits.  Here's another example:

    node /^(foo|bar)\.testing\.com$/ {
        include common
    }

The above example would match either host `foo` or `bar` in the testing.com
domain.

What happens if there are multiple regular expressions or node definitions
set in the same file?

-   If there is a node without a regular expression that matches
    the current client connecting, that will be used first.
-   Otherwise the first matching regular expression wins.

#### Node Inheritance

Nodes support a limited inheritance model.  Like classes, nodes
can only inherit from one other node:

    node 'www2.testing.com' inherits 'www.testing.com' {
        include loadbalancer
    }

In this node definition the `www2.testing.com` inherits any
configuration specified for the `www.testing.com` node in addition
to including the `loadbalancer` class.   In other words, it does
everything "www.testing.com" does, but also takes on some
additional functionality. 

#### Default Nodes

If you create a node named `default`, the node configuration
for default will be used if no other node matches are found.

#### External Nodes

In some cases you may already have an external list of machines
and what roles they perform.  This may be in LDAP, version
control, or a database.  You may also need to pass some
variables to those nodes (more on variables later).

In these cases, writing an [External Nodes](./external_nodes.html)
script can help, and that can take the place of your node definitions.  See
that section for more information.

The Extended Language Tutorial
------------------------------

The [Extended Language Tutorial](./more_language.html) offers more
features of the Puppet language, including details on variable scoping,
conditional expressions, and other features.  You may also learn a lot
about the language by browsing through [Puppet Modules](./modules.html)
 created by others.


